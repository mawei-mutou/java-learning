<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <script>
            /**
             * 原型 prototype
             *  我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype
             *  这给属性对应这一个对象，这个对象就是所谓的原型对象
             *
             *  如果作为普通函数这个属性没有作用
             *  当以构造函数的形式调用时，它所创建的 对象中都会有一个隐含的属性；
             *   指向该该构造函数的原型对象，我们可以通过__proto__来访问该属性
             */
            var a = "全局中的a";

            function Person() {

            }

            function MyClass() {
            }


            var mc = new MyClass();
            var mc2 = new MyClass();
            MyClass();
            //向MyClass的原型对象中添加属性a和方法,属于这一类的所有对象都可以通过__proto__访问到这个原型对象中的所有内容
            MyClass.prototype.a=123;
            MyClass.prototype.sayName = function () {
                aler("hello,我是" + this.name);//也就是可以将一类的对象的公告属性和方法放到原型对象中取，就不用每个对象都创建
            };
            console.log(mc.a);//由于mc中没有自己的a，便像原型对象中取寻找是否存在a
            // mc.a = "v这是mc中a";
            console.log(mc.__proto__);
            console.log(MyClass.prototype);
            console.log(mc.__proto__ == MyClass.prototype);//因为他们都是指向同一个原型对象内存地址，所有事相同的，为true

            console.log(mc.sayName == mc2.sayName);
        </script>
    </head>
    <body>
        
    </body>
</html>